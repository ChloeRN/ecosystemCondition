---
title: "Breareal"
output:
  html_document
---

```{r setup, include=FALSE, message=FALSE}
library(knitr)
library(sf)
library(raster) # kunne kanskje byttet til stars
library(dplyr)
library(lwgeom)
library(tmap)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(data.table)
knitr::opts_chunk$set(echo = TRUE)
```



# Areal av isbreer {-}

<br />

```{r, echo=F}
Ecosystem <- "Fjell" 
Egenskap  <- "Landskapsøkologiske mønstre" 
ECT       <- "Landscape and seascape characteristics" 
Contact   <- "Anders L. Kolstad" 
```

```{r, echo=F}
metaData <- data.frame(Ecosystem,
                       "Økologisk egenskap" = Egenskap,
                       "ECT class" = ECT)
knitr::kable(metaData)
```

<br />
<br />
<hr />

## Introduction
This indicator describes the relative change in glacial extent for each of fire regions in Norway.

## About the underlying data
The indicator uses the maps of glacier extent \(_breatlas_\) from [2018-2019](https://www.nve.no/vann-og-vassdrag/vannets-kretsloep/bre/publikasjoner-publications/breatlas-glacier-inventories/) and compares it to a similar map from 1947-1985. Both maps are owned by NVE (Norsk vassdrags og energidirektorat). The new map is based on Sentinel images, and the old map is a digitised version of the N50 maps, with some additional areal photo interpretation on top. 

### Representativity in time and space
The data set (map) covers the entire Norwegian mainland. There are only two time steps, but we expect changes in glacial extent to be relatively linear or consistent over time.
The older map may have underestimated the glacial extent due to a better chance of smaller snow and ice patches being captured by Sentinel contra aerial photo interpretations. 

### Original units
Area units (e.g. km2)

### Temporal coverage
1947-2019

### Aditional comments about the dataset
None

## Ecosystem characteristic
The indicator was initially designated to the _Abiotiske forhold_ characteristic, but now it is considered under _Landskapsøkologiske mønstre_. The initial justificaton was that glacial melting would influence water availability downstream. Now we put more weight on glaciers as not just resevoirs of ice and water, but as a habitat, and the presence or abundance of a specific habitat can be though of as an aspect of landscape state. 

The indicator is similarly assiged to the SEEA ECT class _C1 Landscape characteristics_.

## Collinearities with other indicators
None that are known

Probable or empirically documented 

## Reference state
The indicator uses the same reference state as all or most of the indicators developed in this and in similar projects, and is defined in Nybø et al (2017): _Fagsystem for fastsetting av god økologisk tilstand_. As glacial extent is primarily, or solely, dependent on climate, we are in a case where we have actual data from the climatic reference period which is the previous normal period 1961-1990. 

## Reference values, thresholds for defining _good ecological condition_, minimum and/or maximum values
The reference value is zero change in glacial extent over time. The theshold for defining good ecological condition as set at a 40% reduction in glacial extnet, as a defult solution. This normalization follows a linear model, although a sigmoidal weibull function might be more appropriate. 

The minumum value is set to zero.

## Uncertainties
Indicator values should ideally come with uncertainties associated with them, but in this case the data is very fixed so we do not attempt to calculate any uncertainties for this indicator. 

## References:
* Andreassen, L.M., & Winsvold, S.H. (eds.). 2012. Inventory of Norwegian glaciers. NVE Rapport 38, Norges Vassdrags- og energidirektorat, 236 s

* Andreassen, L.M., Elvehøy, H., Kjøllmoen, B. & Belart, J.M.C. 2020. Glacier change in Norway since the 1960s – an overview of mass balance, area, length and surface elevation changes. Journal of Glaciology 66: 313–328

* Andreassen, L.M., Nagy, T., Kjøllmoen, B. & Leigh, J.R. 2022. A Sentinel-2 based inventory of Norway’s glaciers and ice-marginal lakes 2018/2019. Journal of Glaciology (in review)

* Winsvold, S.H., Andreassen, L.M. & Kienholz, C.. 2014. Glacier area and length changes in Norway from repeat inventories. The Cryosphere 8: 1885-1903



## Analyses

## Inporting the data sets
There are four data sets:

* glacial atlas
* n50 (the old glacial atlas)
* the regional delineation for Norway (fire regions)
* an outline of mainland Norway

We are assuming all glaciers are found in the mountins, se we do not need to mask the glacial atlsa data using an exosystem delineation map. 



### Glacial atlas
This is the new glacial atlas from 2018 and 2019 based on Sentinell (ref. Liss Marie Andreassen, NVE)
```{r import1}
# This first part is if you are running this from the NINA R server. 
#breatlas <- sf::st_read('/data/P-Prosjekter/41201042_okologisk_tilstand_fastlandsnorge_2020_dataanaly/fjell2021/data/breatlas/breatlas_2018_2019/Breatlas_20182019_temp20210922_lma.shp')

breatlas <- sf::st_read('P:/41201042_okologisk_tilstand_fastlandsnorge_2020_dataanaly/fjell2021/data/breatlas/breatlas_2018_2019/Breatlas_20182019_temp20210922_lma.shp')
```

All maps made in this project need to have the same CRS:  EPSG:25833 - ETRS89 / UTM zone 33N.
This one is in UTM 33N ETRS89, even if it is defined in the old Proj.4 way.

There are 6915 polygons. Let's calculate the area of the polygons and study the distribution of size classes. 
```{r breareal}
breatlas$area <- st_area(breatlas)
par(mfrow=c(1,2))
hist(breatlas$area)
plot(breatlas$area)
```
Most polygons are small, and then there are a couple of very big ones. The larges is 50 km2. 


### Map of Norway
This map is stored on the GitHub repository under _indicators/data/_. I will also transform it to the same UTM33 projection as the forst data set, and plot them on top of each other.
```{r import2}
nor <- readRDS('data/norway_outline.RDS')%>%
  st_as_sf()%>%
  st_transform(crs=crs(breatlas))
plot(nor$geometry, axes=T, main = "Breatlas 2018-2019")
  plot(breatlas$geometry, add=T, border = "blue")

```


### N50
This is the old glacial extent map. Import it and transform it, same as before.

```{r import3}
#n50 <- sf::st_read('/data/P-Prosjekter/41201042_okologisk_tilstand_fastlandsnorge_2020_dataanaly/fjell2021/data/breatlas/n50/cryoclim_GAO_NO_1952_1985_UTM_33N.shp')%>%
#  st_transform(crs = crs(breatlas))

n50 <- sf::st_read('P:/41201042_okologisk_tilstand_fastlandsnorge_2020_dataanaly/fjell2021/data/breatlas/n50/cryoclim_GAO_NO_1952_1985_UTM_33N.shp')%>%
  st_transform(crs = crs(breatlas))

```

```{r}
plot(nor$geometry, axes=T, main = "n50 - 1952-1985")
  plot(n50$geometry, add=T, border = "red")
```

Let's now plot it all on top of each other.

```{r plotter-alt}

# define some boundary boxes for zooming in on specific regions
myExt <- raster::extent(c(0, 100000, 6840000, 6900000))
myExt2 <- raster::extent(c(5000, 10000, 6880000, 6885000))

# Prepare plotting device with one row, three columns
par(mfrow=c(1,3))

# Create three maps, each zooming in a bit further.
plot(nor$geometry, axes=T)
    plot(n50$geometry,  border = "orange", col = scales::alpha("orange", 1), add=T)
    plot(myExt, add=T, lwd=2)

plot(nor$geometry, xlim=c(0, 100000),
          ylim=c(6840000, 6900000),
          axes=T)
    plot(n50$geometry, add=T, col = "grey")
    plot(myExt2, add=T, lwd=3, col="orange")

# for this last map I plot the old extent in red and the new as grey on top. The red areas still visible will be areas where the glaciers have retreated.        
plot(nor$geometry, xlim=c(5000, 10000),
          ylim=c(6880000, 6885000),
     axes=T)
    plot(n50$geometry, add=T, col = "red")
    plot(breatlas$geometry, add=T, col = "grey")
    
```
The red areas in the map to the far right is where the ice has retreated for a selected glacier on the west coast. 
Now we need to devide the map into regions to then compare the area in n50 with the new glacial extent map _breatlas_.


### Regions
Importing a shape file with the regional delineation. 

```{r import4}
#reg <- st_read("/data/P-Prosjekter/41201042_okologisk_tilstand_fastlandsnorge_2020_dataanaly/FINAL/Raw_data/Geografisk_oppdeling/regioner_2010/regNorway_wgs84 - MERGED.shp")%>%
#  st_transform(crs = crs(breatlas))

reg <- st_read("P:/41201042_okologisk_tilstand_fastlandsnorge_2020_dataanaly/FINAL/Raw_data/Geografisk_oppdeling/regioner_2010/regNorway_wgs84 - MERGED.shp")%>%
  st_transform(crs = crs(breatlas))


```

Let's plot it to make sure it is correct.
```{r}
plot(nor$geometry, axes=T)
  plot(reg$geometry, add=T, border = "black", 
       col = scales::alpha(c("blue", 
                             "red", 
                             "green",
                             "yellow",
                             "brown"), .2))
```

Get the regiona names
```{r}
unique(reg$region)
```

These are odd. Let me fix the Norwegian letetrs manually.
```{r}
reg$region[reg$region=="Ã\u0098stlandet"] <- "Østlandet"
reg$region[reg$region=="SÃ¸rlandet"] <- "Sørlandet"
```


Before going any further I need to fix a problem with glacier polygons crossing themselves. 
```{r}
table(st_is_valid(breatlas))
```
 68 polygons are not valid. 
 Let's look at the first four reasons for why that is. 

```{r}
unique(st_is_valid(breatlas, reason=T))[1:5]

```

There is a convinient function to fix this.
```{r make-valid}
# requires lwgeom
breatlas2 <- st_make_valid(breatlas)
table(st_is_valid(breatlas2))

# same result:
#breatlas2 <- st_buffer(breatlas, 0.0)
#table(st_is_valid(breatlas2))

```


Let me plot the new, fixed map on top of the old to see if the match. I give the new valid map a blue transparent colour, and the old map a yellow and transparent colour.  
```{r}
plot(nor$geometry, xlim=c(5000, 10000),
          ylim=c(6880000, 6885000),
     axes=T)
    plot(breatlas2$geometry, add=T, col = scales::alpha("blue",0.5))
    plot(breatlas$geometry, add=T, col = scales::alpha("yellow",0.5))
```
This seems to have worked. 
Notice also how some of these larger polygons are somewhat arbitrarely divided into several adjoining polygons. This is only so for the new map, not the old n50 map.

Delete the invalid data set.
```{r}
breatlas <- breatlas2
rm(breatlas2)
```



## Glacial area per region
### Contemporary area

Here is one method for getting the glacial area for each region.
```{r intersection}
# This intersection operation is a bit heavy, so I do it once and store it locally so that I can import it again quickly. 
#brealtas_reg <- st_intersection(breatlas, reg)
#saveRDS(brealtas_reg, "../data/brealtas_reg_helperfile.rds")

# Importing what I create above
brealtas_reg <- readRDS("data/brealtas_reg_helperfile.rds")
```


Checking what happens to polygons that span to regions. Central Norway in red and western Norway in green. 50% transparency means we should get a third colour where and if they overlap.
```{r}
plot(brealtas_reg$geometry[brealtas_reg$region=="Midt-Norge"], 
    col = scales::alpha("red",0.5), border=NA, axes=T, 
     ylim=c(6900000, 6905000),
     xlim=c(85000, 100000))
plot(brealtas_reg$geometry[brealtas_reg$region=="Vestlandet"], 
     col = scales::alpha("green",0.5), border=NA, add=T)
  plot(nor$geometry, add=T)
```
It worked fine. 

Calculating the area of the polygons
```{r plotting-area-per-region}
#Calculating the area of the polygons
brealtas_reg$area_crop <- st_area(brealtas_reg)

# summing the area for each region
bretabell <- tapply(
       brealtas_reg$area_crop,
       brealtas_reg$region,
       FUN = sum)

# converting from m2 to km2
bretabell <- bretabell/1000000

# plotting
barplot(
  bretabell,
  ylab="Breareal (km2)"
)
```
Southern Norway has <1km2 of glaciers in 2018-2019.


### Same for N50
```{r intersection2}
n50x <- st_make_valid(n50)
#n50_reg <- st_intersection(n50x, reg)
#saveRDS(n50_reg, "../data/n50_helperfile.rds")
n50_reg <- readRDS("data/n50_helperfile.rds")
```


```{r}
plot(n50_reg$geometry[n50_reg$region=="Midt-Norge"], 
    col = scales::alpha("red",0.5), border=NA, axes=T, 
     ylim=c(6900000, 6905000),
     xlim=c(85000, 100000))
plot(n50_reg$geometry[n50_reg$region=="Vestlandet"], 
     col = scales::alpha("green",0.5), border=NA, add=T)
  plot(nor$geometry, add=T)
```
Thats good. 
Now I will plot the reference values (n50) and the contemporary data together.
```{r plotting-ref-and-ind}
n50_reg$area_crop <- st_area(n50_reg)

n50tabell <- tapply(
       n50_reg$area_crop,
       n50_reg$region,
       FUN = sum)
n50tabell <- n50tabell/1000000 


barplot(
  n50tabell,
  ylab="Breareal (km2)",
  col="grey"
)
barplot(
  bretabell,
  ylab="Breareal (km2)",
  add=T,
  col="grey30"
)

```

In the figure above, the glacial area in the reference periond is in light grey and todays area is in dark grey. The height of the light grey bar depicts the reductino in glacial area.

There was a little more glaicers in southern Norway in the reference period, but only 4 km2. The condition here will be very poor, but this is not what we want, because glacial area is not at all representative of mountianareas in souther Norway. 


## Scaled indicator values
Making a table with the indicator values.
```{r skalert}
myTbl <- tibble(region           = names(bretabell),
                indikator        = bretabell,
                referanseverdi   = n50tabell)
myTbl$skalert_indikator <- myTbl$indikator/myTbl$referanseverdi
myTbl
```

Scaling and clipping the regions against the outline of Norway

```{r, message=FALSE}
# paste the scaled indicato values into the shape file with the regions, using the match function to make sure the align correctly
reg$skalert_indikator <- myTbl$skalert_indikator[match(reg$region, myTbl$region)]

# cutting away the marine areas
reg_clipped <- st_intersection(reg, nor)
```

```{r}
# round of to 2 decimals
reg_clipped$skalert_indikator_r <- round(reg_clipped$skalert_indikator, 2)
```

Plotting an interactiv map with scaled indicator values
```{r}
tmap_mode("view")
tm_shape(reg_clipped) + 
  tm_polygons(col="skalert_indikator", border.col = "white")+
  tm_text("skalert_indikator_r", size=1.5)+
  tm_shape(nor)+
  tm_polygons(alpha = 0,border.col = "black")
```


Det er 4 måter å kalkulere den nasjonale indikatorverdien på:

1) ta gjennomsnitt av de skalerte regionale indikatorverdiene og la alle regionene telle likt (regional skaleringsmetode)
```{r}
(alt1 <- mean(reg_clipped$skalert_indikator))
```

2) summer indikatorverdien for hele landet og del på den summerte referanseverdien for hele landet (nasjonal metode)
```{r}
(alt2 <- sum(bretabell)/sum(n50tabell))
```


3) summere skalerte regionale indikatorverdier etter å ha gitt de ulike vekt grunnet totalarealet til regionen (arealveid metode)

```{r}
reg_clipped$areal <- st_area(reg_clipped$geometry)/1000000

totalArea <- sum(reg_clipped$areal)

reg_clipped$skalert_indikator_v <- reg_clipped$skalert_indikator*
  reg_clipped$areal


sumSkalerteIndikatorer <- sum(reg_clipped$skalert_indikator_v)

(alt3 <- sumSkalerteIndikatorer/totalArea)
```
4) summere skalerte regionale indikatorverdier etter å ha gitt de ulike vekt grunnet fjellareal (fjellarealveid metode)


For dette trenger jeg [fjellareal per region](fjellareal-per-region.html):
```{r}
(fjellareal <- readRDS("../data/fjellareal.rds"))
```


```{r}
reg_clipped$fjellareal <- fjellareal$Fjellareal[match(reg_clipped$region, fjellareal$Region)]
reg_clipped$skalert_indikator_v2 <- reg_clipped$skalert_indikator*
  reg_clipped$fjellareal
(alt4 <- sum(reg_clipped$skalert_indikator_v2)/sum(reg_clipped$fjellareal))
```
Her er alternativene oppsummert:

1. Indeksverdi `r round(alt1, 2)`. Aggregeringsmetoden er tvilsom.

2. Indeksverdi `r round(alt2, 2)`. Aggregeringsmetoden sier oss hvordan den TOTALE endringen i breareal har vært for Norge sett under ett.

3. Indeksverdi `r round(alt3, 2)`. Aggregeringsmetoden er igjen tvilsom.

4. Indeksverdi `r round(alt4, 2)`. Aggregeringsmetoden sier oss hvordan den GJENNOMSNITTLIGE endringen i breareal har vært for Norge sett under ett (jf metoden i NI).

Her kan det diskuteres hva som egentlig er best, men vi har valgt å gå for alt 4 for å være konsistent med SEEA EA bl.a. Indikatorverdien for Norge er da 0.62. 

## Usikkerhet
NVE oppgir 3% usikkerhet ved metoden. Dette tolker jeg som at +- 3% utgjør 99.9%CI for estimatet (ca 2 SD).
```{r}
reg <- c("N", "C", "E", "W", "S")
myTbl$reg <- c("C", "N", "S", "W", "E")

breTbl <- data.frame(
  reg = rep(reg, each=10000),
  indikatorverdi = NA,
  refVerdi = NA,
  val = NA
)
breTbl2 <- breTbl

for(i in reg){
  #print(i)
  temp <- breTbl2[breTbl2$reg==i,]
  temp$indikatorverdi <- rnorm(10000, myTbl$indikator[myTbl$reg==i], myTbl$indikator[myTbl$reg==i]*0.015)
  temp$refVerdi <- rnorm(10000, myTbl$referanseverdi[myTbl$reg==i], myTbl$referanseverdi[myTbl$reg==i]*0.015)
  breTbl$indikatorverdi[breTbl$reg==i] <- temp$indikatorverdi
  breTbl$refVerdi[breTbl$reg==i] <- temp$refVerdi
}

# summary(breTbl$indikatorverdi) # no zeros
# summary(breTbl$refVerdi) # no zeros

breTbl$val <- breTbl$indikatorverdi/breTbl$refVerdi
breTbl$unscaledVal <- breTbl$refVerdi-breTbl$indikatorverdi
#breTbl <- dplyr::select(breTbl, -refVerdi)
breTbl$year <- 2019
```

Må jeg trunkere?
```{r}
summary(breTbl$val)
```
Nei, alle verdier er mellom 0 og 1.

Så må jeg finne den nasjonale tilstanden. 

```{r}
breNorge <- data.frame(
  reg = rep("Norge", 10000),
  indikatorverdi = NA,
  refVerdi = NA,
  val = NA,
  unscaledVal = NA,
  year = 2019
)

# Legger inn vektene på nytt
wgt <- readRDS("../data/fjellareal.rds")
wgt$Fjellareal2 <- wgt$Fjellareal/max(wgt$Fjellareal)
wgt$reg <- c("N", "C", "E", "W", "S")


temp <- breTbl
    
temp2 <- c(
      sample(temp$val[temp$reg == "N"], wgt$Fjellareal2[wgt$reg == "N"]*1000, replace =T),
      sample(temp$val[temp$reg == "E"], wgt$Fjellareal2[wgt$reg == "E"]*1000, replace =T),
      sample(temp$val[temp$reg == "W"], wgt$Fjellareal2[wgt$reg == "W"]*1000, replace =T),
      sample(temp$val[temp$reg == "S"], wgt$Fjellareal2[wgt$reg == "S"]*1000, replace =T),
      sample(temp$val[temp$reg == "C"], wgt$Fjellareal2[wgt$reg == "C"]*1000, replace =T)
    )

for(i in 1:10000){
 
  breNorge$unscaledVal[i] <- 
    sum(
      sample(temp$unscaledVal[temp$reg == "N"],1),
      sample(temp$unscaledVal[temp$reg == "E"],1),
      sample(temp$unscaledVal[temp$reg == "W"],1),
      sample(temp$unscaledVal[temp$reg == "S"],1),
      sample(temp$unscaledVal[temp$reg == "C"],1))
  
  breNorge$refVerdi[i] <- 
    sum(
      sample(temp$refVerdi[temp$reg == "N"],1),
      sample(temp$refVerdi[temp$reg == "E"],1),
      sample(temp$refVerdi[temp$reg == "W"],1),
      sample(temp$refVerdi[temp$reg == "S"],1),
      sample(temp$refVerdi[temp$reg == "C"],1))
  
   breNorge$indikatorverdi[i] <- 
    sum(
      sample(temp$indikatorverdi[temp$reg == "N"],1),
      sample(temp$indikatorverdi[temp$reg == "E"],1),
      sample(temp$indikatorverdi[temp$reg == "W"],1),
      sample(temp$indikatorverdi[temp$reg == "S"],1),
      sample(temp$indikatorverdi[temp$reg == "C"],1))
}

breNorge$val <- sample(temp2, 10000, replace=T)

breTbl <- rbind(breTbl, breNorge)

```
# Eksport CSV
```{r, eval=F}
expdat <- dplyr::select(breTbl, reg, year, val)
write.csv(expdat, "../output/indicator_values/breareal.csv")
```


# Plotting
```{r}
eval(parse("indicator_plots2.R", encoding="UTF-8"))
```

```{r, message=F, eval=F}
png("../output/indicatorPlots/breareal.png", 
    units="in", width=5, height=7, res=300)

par(mfrow=c(1,1), mar=c(4.5,
                        5.5,
                        0,
                        2))

indicator_plot2(dataset = dplyr::select(breTbl, reg, year, val),
               yAxisTitle = "Breareal skalert mot referanseverdi",
               lowYlimit = 0,
               upperYlimit = 1,
               yStep = .2,
               minyear = 2018,
               maxyear = 2022,
               colours = c("#FFB25B", "#2DCCD3", "#004F71", "#7A9A01", "#93328E", "dark grey"),
               legendPosition = "right",
               legendInset = 0,
               move = 0.1,
               horizontal = F,
               legendTextSize = 1.25)
dev.off()
```

```{r}
png("../output/indicatorPlots/breareal_uskalert.png", 
    units="in", width=5, height=7, res=300)

par(mfrow=c(1,1), mar=c(4.5,
                        5.5,
                        2,
                        2))
indicator_plot2(dataset = dplyr::select(breTbl, reg, year, val = unscaledVal),
               yAxisTitle = expression(paste("Tapt breareal (km "^"-2"*")")),
               lowYlimit = 0,
               upperYlimit = 1100,
               yStep = 100,
               minyear = 2018,
               maxyear = 2022,
               colours = c("#FFB25B", "#2DCCD3", "#004F71", "#7A9A01", "#93328E", "dark grey"),
               legendPosition = "right",
               legendInset = 0,
               move = 0.1,
               horizontal = F,
               legendTextSize = 1.25)
dev.off()
```

```{r}
breTblTemp <- data.table::melt(breTbl,
                   id.vars = c("year", "reg"),
                   measure.vars = c("refVerdi", "indikatorverdi"),
                   variable.name = "year",
                   value.name = "val")
breTblTemp <- breTblTemp[,-1]

breTblTemp$year <- as.character(breTblTemp$year)
breTblTemp$year[breTblTemp$year == "refVerdi"] <- "1969"
breTblTemp$year[breTblTemp$year == "indikatorverdi"] <- "2019"
breTblTemp$year <- as.numeric(breTblTemp$year)


png("../output/indicatorPlots/breareal_uskalert_tidsserie.png", 
    units="in", width=5, height=7, res=300)

par(mfrow=c(1,1), mar=c(4.5,
                        5.5,
                        2,
                        2))
indicator_plot2(dataset = dplyr::select(breTblTemp, reg, year, val = val),
               yAxisTitle = expression(paste("Breareal (km "^"-2"*")")),
               lowYlimit = 0,
               upperYlimit = 4500,
               yStep = 1000,
               minyear = 1955,
               maxyear = 2022,
               colours = c("#FFB25B", "#2DCCD3", "#004F71", "#7A9A01", "#93328E", "dark grey"),
               legendPosition = "topright",
               legendInset = 0,
               move = 0.1,
               horizontal = F,
               legendTextSize = 1.25)
dev.off()
```

# Oppsummering



```{r, echo=F}

finalTbl <- aggregate(data=breTbl,
          val~year+reg,
          FUN= function(x) round(
            quantile(x, c(.025, .5, .975)), 2))

finalTbl <- do.call(data.frame, finalTbl)
names(finalTbl) <- c("year", "reg", "low", "med", "upp")

DT::datatable(
  finalTbl, 
  extensions = "FixedColumns",
  options = list(
    scrollX = TRUE,
    scrollY=T,
    pageLength = 10
  ))
```


```{r}
finalTbl2 <- aggregate(data=breTbl,
          indikatorverdi~year+reg,
          FUN= function(x) round(
            quantile(x, c(.025, .5, .975)), 2))

finalTbl2 <- do.call(data.frame, finalTbl2)
names(finalTbl2) <- c("year", "reg", "val_low", "val_med", "val_upp")

finalTbl3 <- aggregate(data=breTbl,
          refVerdi~year+reg,
          FUN= function(x) round(
            quantile(x, c(.025, .5, .975)), 2))

finalTbl3 <- do.call(data.frame, finalTbl3)
names(finalTbl3) <- c("year", "reg", "ref_low", "ref_med", "ref_upp")

finalTbl4 <- cbind(finalTbl2, finalTbl3[,3:5])
```

```{r, eval=F}
myReg <- c("E", "S", "W", "C", "N", "Norge")
labs = c("Østlandet","Sørlandet","Vestlandet","Midt-Norge","Nord-Norge","Norge")




bar <- ggplot(finalTbl)+
  geom_bar(aes(x=factor(reg, level = myReg), y=med), stat="identity", alpha=0.7)+
  geom_errorbar(aes(x=factor(reg, level = myReg), y=med, ymin = low, ymax=upp),
                width=0.5,
                size=1.2)+
  ylab("Breareal skalert mot referanseverdi")+
  xlab("")+
  scale_x_discrete(breaks = myReg,
                   labels= labs)+
  
  theme_bw(base_size = 20)+
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
  )

(barSTacked <- ggplot(finalTbl4)+
  geom_bar(aes(x=factor(reg, level = myReg), y=val_med), 
           stat="identity")+
  geom_errorbar(aes(x=factor(reg, level = myReg), 
                    y=val_med, ymin = val_low, ymax=val_upp),
                width=0.5,
                size=1.2)+
    
  geom_bar(aes(x=factor(reg, level = myReg), y=ref_med), 
           stat="identity", alpha=0.7)+
  geom_errorbar(aes(x=factor(reg, level = myReg), 
                    y=ref_med, ymin = ref_low, ymax=ref_upp),
                width=0.5,
                size=1.2)+
    
  ylab(expression(paste("Breareal (km "^"-2"*")")))+
  xlab("")+
  scale_x_discrete(breaks = myReg,
                   labels= labs)+
  theme_bw(base_size = 20)+
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
  ))

figure <- ggarrange(bar, barSTacked,
                    ncol = 2)


png("../output/indicatorPlots/breareal_barplot.png", 
    units="in", width=10, height=7, res=300)
figure
dev.off()
```

![](../output/indicatorPlots/breareal_barplot.png)

![](../output/indicatorPlots/breareal.png)


![](../output/indicatorPlots/breareal_uskalert.png)
![](../output/indicatorPlots/breareal_uskalert_tidsserie.png)

